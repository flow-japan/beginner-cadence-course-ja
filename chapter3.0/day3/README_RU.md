# Глава 3 День 3 - Ссылки

Как дела, ребята из Flow. Сегодня мы поговорим о ссылках, еще одной важной части языка программирования Cadence.

## Видео

Если вы хотите посмотреть видео о ссылках, то переходите сюда: https://www.youtube.com/watch?v=mI3KC-5e81E

## Что такое ссылка?

Проще говоря, ссылка - это способ взаимодействия с частью данных без необходимости иметь эту часть данных. Сразу же можно представить, насколько это полезно для ресурсов. Представьте себе мир, в котором вам не нужно перемещать ресурс 1000 раз, чтобы просмотреть или обновить его поля. Ах, такой мир существует! Ссылки здесь, чтобы спасти положение.

## Ссылки в Cadence

В Cadence ссылки *почти всегда* используются на структуры или ресурсы. Не имеет смысла делать ссылку на строку, число или базовый тип данных. Но, безусловно, имеет смысл делать ссылки на вещи, которые мы не хотим часто перемещать. 

Перед ссылками всегда используется символ `&`. Рассмотрим пример:

```cadence
pub contract Test {

    pub var dictionaryOfGreetings: @{String: Greeting}

    pub resource Greeting {
        pub let language: String
        init(_language: String) {
            self.language = _language
        }
    }

    pub fun getReference(key: String): &Greeting? {
        return &self.dictionaryOfGreetings[key] as &Greeting?
    }

    init() {
        self.dictionaryOfGreetings <- {
            "Hello!": <- create Greeting(_language: "English"), 
            "Bonjour!": <- create Greeting(_language: "French")
        }
    }
}
```

В приведенном выше примере видно, что `getReference` возвращает тип `&Greeting?`, что просто означает "Необязательная ссылка на тип `@Greeting`". Внутри функции происходит несколько вещей:
1. Сначала мы получаем ссылку на значение по адресу `key`, выполняя команду `&self.dictionaryOfGreetings[key]`. 
2. Мы "приводим тип" ссылки, делая `as &Greeting?`. Обратите внимание, что это необязательный тип, что имеет смысл, потому что, когда мы индексируем словари, они возвращают необязательный тип.

Обратите внимание, что если бы мы забыли `as &Greeting?`, Cadence накричал бы на нас и сказал "ожидаю выражение приведения". Это потому, что в Cadence **вы должны приводить тип при получении ссылки**. Приведение типа - это когда вы сообщаете Cadence тип, в качестве которого вы получаете ссылку, что и делает `as &Greeting?`. Он говорит: "Получите эту необязательную ссылку, которая является ссылкой &Greeting". Если это не так, мы прервем выполнение программы.

Теперь, возможно, вы задаетесь вопросом: "Как я могу развернуть эту необязательную ссылку?". Вы можете сделать это следующим образом:
```cadence
pub fun getReference(key: String): &Greeting {
    return (&self.dictionaryOfGreetings[key] as &Greeting?)!
}
```

Обратите внимание, что мы оборачиваем все это и используем оператор принудительного разворачивания `!` для разворачивания, как обычно. Он также изменяет возвращаемый тип на необязательный `&Greeting`. Обязательно измените это в своем коде.

Теперь, когда мы можем получить ссылку, мы можем получить ссылку в транзакции или скрипте следующим образом:

```cadence
import Test from 0x01

pub fun main(): String {
  let ref = Test.getReference(key: "Hello!")
  return ref.language // returns "English"
}
```

Обратите внимание, что для этого нам не пришлось никуда перемещать ресурс! В этом и заключается прелесть ссылок. 

## Заключение

Ссылки не так уж плохи, верно? Вот основные два пункта:
1. Вы можете использовать ссылки для получения информации без перемещения ресурсов.
2. Вы ДОЛЖНЫ "привести тип" ссылки при ее получении, иначе вы получите ошибку.

Однако к сылкам мы еще вернемся. Они будут ИСКЛЮЧИТЕЛЬНО важны, когда мы будем говорить о хранении учетных записей в следующей главе.

## Квесты

1. Создайте собственный контракт, хранящий словарь ресурсов. Добавьте функцию для получения ссылки на один из ресурсов в словаре.

2. Создайте скрипт, который считывает информацию с этого ресурса, используя ссылку из функции, которую вы определили в части 1. 

3. Объясните своими словами, почему ссылки могут быть полезны в Cadence.

