# Глава 5 День 1 - Условия Pre/post и события

Сегодня мы изучим две концепции, которые, хотя и довольно просты, но очень часто встречаются в Cadence.

## Видео

Pre/post условия: https://www.youtube.com/watch?v=WFqoCZY36b0

События: https://www.youtube.com/watch?v=xRHG6Kgkxpg

## Условия Pre/post

До сих пор мы узнали только об одном способе прервать программу, если что-то не так: ключевое слово `panic`. `panic` - это ключевое слово, которое полностью отменяет то, что произошло в коде, если его вызвать, и посылает вместе с ним сообщение. Вот пример:

```cadence
pub fun main(): String {
  let a: Int = 3

  if a == 3 {
    panic("This script will never work because it will always panic on this line.")
  }

  return "Will never get to this line."
}
```

Это довольно глупый пример, но суть вы поняли. Он никогда не вернется, потому что всегда будет паниковать.

Часто мы хотим обрабатывать ошибки более понятным способом, а также реализовать концепцию, называемую "fail fast". В блокчейне операции стоят очень дорого. Поэтому за транзакции взимается дорогая комиссия. "Fail fast" - это способ программирования, при котором ваш код завершается как можно быстрее, если что-то не так, чтобы не тратить время на выполнение без причины.

Условия Pre/post идеально подходят для этого. Они позволяют нам указать очень четкий способ отказа, если что-то не так до (pre) или после (post) вызова функции. Давайте рассмотрим пример:

```cadence
pub contract Test {

  pub fun logName(name: String) {
    pre {
      name.length > 0: "This name is too short."
    }
    log(name)
  }

}
```

В примере выше мы определяем "предусловие" для функции `logName`. Оно гласит: "Если длина имени не больше 0, `panic` выдает сообщение: 'Это имя слишком короткое'".

Предусловия и постусловия **должны** быть определены первым делом в функции, их нельзя помещать в середину или в конец. Для того, чтобы pre/post-условие прошло, условие должно быть `true', иначе оно `panic' со строкой после.

Post-условия - это то же самое, только они проверяются в конце функции (они все равно должны быть определены в начале). Я знаю, это запутанно, но вы привыкнете):


```cadence
pub contract Test {

  pub fun makePositiveResult(x: Int, y: Int): Int {
    post {
      result > 0: "The result is not positive."
    }
    return x + y
  }

}
```

Возможно, вы задаетесь вопросом: "Что это за переменная `result`? Мы никогда не определяли ее". Вы правы! Post-условия очень круты, потому что они поставляются с переменной `result`, которая уже равна значению возвращаемого результата. Так что если мы возвращаем `x + y`, `result` будет представлять это значение. Если возвращаемого значения нет, то `result` не существует.

Кроме того, вы можете использовать функцию `before()` внутри вашего условия post, чтобы получить доступ к значению чего-либо до того, как функция изменила это значение, даже после того, как функция выполнилась. 

```cadence
pub contract Test {

  pub resource TestResource {
    pub var number: Int

    pub fun updateNumber() {
      post {
        before(self.number) == self.number - 1
      }
      self.number = self.number + 1
    }

    init() {
      self.number = 0
    }

  }

}
```

Приведенный выше код всегда будет работать, потому что выполнено постусловие. В нем говорится: "После выполнения функции `updateNumber` убедитесь, что обновленное число на 1 больше, чем то, которое было до выполнения этой функции". Что всегда верно в данном случае.

### Важное замечание

Важно понимать, что на самом деле делает `panic` или pre/post условия. Они "прерывают" транзакцию, что означает, что ни одно из состояний на самом деле не изменяется.

Example:
```cadence
pub contract Test {

  pub resource TestResource {
    pub var number: Int

    pub fun updateNumber() {
      post {
        self.number == 1000: "Will always panic!" // when this panics after the function is run, `self.number` gets reset back to 0
      }
      self.number = self.number + 1
    }

    init() {
      self.number = 0
    }

  }

}
```

## События

События - это способ для смарт-контракта сообщить внешнему миру о том, что что-то произошло. 

Например, если мы чеканим NFT, мы хотим, чтобы внешний мир знал, что NFT был чеканен. Конечно, мы могли бы просто постоянно проверять контракт на предмет обновления `totalSupply` или чего-то еще, но это очень неэффективно. Почему бы просто не попросить контракт сообщить об этом нам?

Вот как вы можете определить событие в Cadence:

```cadence
pub contract Test {

  // define an event here
  pub event NFTMinted(id: UInt64)

  pub resource NFT {
    pub let id: UInt64

    init() {
      self.id = self.uuid

      // broadcast the event to the outside world
      emit NFTMinted(id: self.id)
    }

  }

}
```

Вы можете видеть, что мы определили событие под названием `NFTMinted` следующим образом: `pub event NFTMinted(id: UInt64)`. Обратите внимание, что события ВСЕГДА являются `pub`/`access(all)`. Затем мы транслируем событие с помощью ключевого слова `emit`, которое отправляет его в блокчейн.

Вы также можете передать параметры в событие, чтобы отправить данные во внешний мир. В данном случае мы хотим сообщить миру, что был отчеканен NFT с определенным идентификатором, чтобы любой клиент, читающий наши события, знал, что был отчеканен конкретный NFT.

Это делается для того, чтобы клиенты (люди, читающие наш контракт) могли знать, когда что-то происходит, и соответствующим образом обновить свой код. Может быть, мы могли бы сделать крутой сайт, который запускает фейерверк с моим лицом на нем каждый раз, когда чеканится NFT! :D

## Заключение

Вот и все на сегодня! Надеюсь, вам понравился этот короткий урок. 

## Квесты

1. Опишите, что такое событие и почему оно может быть полезным для пользователя.

2. Развернуть контракт с событием в нем, и выдать событие в другом месте контракта, указывая, что оно произошло.

3. Используя контракт из шага 2, добавьте несколько pre и post условий в свой контракт, чтобы привыкнуть к их написанию.

4. Для каждой из приведенных ниже функций (NumberOne, NumberTwo, NumberThree) следуйте инструкциям.

```cadence
pub contract Test {

  // TODO
  // Скажите, будет ли эта функция записывать имя в консоль или нет.
  // name: 'Jacob'
  pub fun numberOne(name: String) {
    pre {
      name.length == 5: "This name is not cool enough."
    }
    log(name)
  }

  // TODO
  // Скажите, вернет ли эта функция значение?
  // name: 'Jacob'
  pub fun numberTwo(name: String): String {
    pre {
      name.length >= 0: "You must input a valid name."
    }
    post {
      result == "Jacob Tucker"
    }
    return name.concat(" Tucker")
  }

  pub resource TestResource {
    pub var number: Int

    // TODO
    // Скажите, будет ли эта функция записывать в консоль обновленное число.
    // Также напишите значение `self.number` после ее выполнения.
    pub fun numberThree(): Int {
      post {
        before(self.number) == result + 1
      }
      self.number = self.number + 1
      return self.number
    }

    init() {
      self.number = 0
    }

  }

}
```